#!/usr/bin/perl
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

sub trim ($) {
	my ($s) = @_;
	$s =~ s/^\s+|\s+$//g;
	return $s;
}

sub match (\@@) {
	my ($all, @pre) = @_;
	my @all = @$all;
	return 0 if @all < @pre;
	while (@pre) {
		return 0 if shift @pre ne shift @all;
	}
	return 1;
}

sub shift_until (\@$) {
	my ($arr, $until) = @_;
	my @res;
	while (@$arr && $arr->[0] ne $until) {
		push @res, shift @$arr;
	}
	return @res;
}

sub out {
	my (@strs) = @_;
	print @strs;
}

sub outln {
	my (@strs) = @_;
	out @strs, "\n";
}

sub attrs (\@$) {
	my ($tok, $to) = @_;
	if (@$tok && $tok->[0] eq 'attr') {
		shift @$tok;
		while (@$tok) {
			my $attr = shift @$tok;
			$attr =~ s/(\W*)$//;
			my ($options) = ($1);
			out "$attr [shape=ellipse";
			if ($options =~ /!/) {
				out ',style=filled,fillcolor="#cccccc"';
			}
			outln '];';
			outln "$to -- $attr;";
		}
	}
}

sub out_entity (\@$) {
	my ($tok, $peri) = @_;
	shift @$tok;
	my $e = shift @$tok;
	outln "$e [shape=box,peripheries=$peri];";
	attrs @$tok, $e;
}

sub out_relate_diamond ($$) {
	my ($r, $peri) = @_;
	outln "$r [shape=diamond,peripheries=$peri];";
}

sub out_relate_entities ($@) {
	my ($r, @es) = @_;
	foreach my $e (@es) {
		$e =~ s/(<(\w+)>)?(\W*)$//;
		my ($relname, $options) = ($2, $3);
		out "$r -- $e";
		my @out_options;
		if ($options !~ /\*/) {
			push @out_options, 'arrowhead=normal';
		}
		if ($options =~ /!/) {
			push @out_options, 'style=bold';
		}
		if ($relname) {
			push @out_options, "label=$relname";
		}
		if (@out_options) {
			out '[', join(',', @out_options), ']';
		}
		outln ';';
	}
}

outln "graph er {";

while (<>) {
	my @tok = split /\s+/, trim $_;
	if (match @tok, qw/entity/) {
		out_entity @tok, 1;
	}
	elsif (match @tok, qw/relate/) {
		shift @tok;
		my $r = shift @tok;
		out_relate_diamond $r, 1;
		out_relate_entities $r, shift_until @tok, 'attr';
		attrs @tok, $r;
	}
	elsif (match @tok, qw/weak entity/) {
		shift @tok;
		out_entity @tok, 2;
	}
	elsif (match @tok, qw/weak relate/) {
		shift @tok;
		shift @tok;
		my $r = shift @tok;
		out_relate_diamond $r, 2;
		my $strong = shift @tok;
		my $weak = shift(@tok) . '!*';
		out_relate_entities $r, $strong, $weak;
		attrs @tok, $r;
	}
}

outln "}";

